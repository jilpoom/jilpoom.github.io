---
title: 자바스크립트의 동시성 처리
description: 기본적으로 싱글 스레드 구조인 자바스크립트는 한 번에 하나의 요청만을 처리할 수 있다. Node 환경에서는 어떻게 이 문제를 해결했을까
date : '2024-02-25T16:25:00Z'
---

Javascript의 메인 스레드인 이벤트 루프(Event Loop)는 싱글 스레드(Single) 구조로써, 한 번의 요청을 수행하는 동안, 다른 요청을 처리할 수 없다. 하지만 우리는 javascript의 비동기를 사용하면서 마치 동시에 여러 스레드가 수행되는 것처럼 로직을 병렬로 처리할 수 있다.

이러한 방법이 가능한 이유는 자바스크립트 이벤트 루프의 작동 원리를 통해 이해할 수 있다.

# 자바스크립트 런타임 모델의 작동 원리
런타임 모델의 큰 그림을 그려보자. 다음의 몇 가지만 기억하면 된다.

![img.png](img.png)

## 콜스택에 올라야 비로소 함수가 실행된다.

다음과 같은 자바스크립트 로직이 있다고 해보자.
```js
function A() {
  B();
  return 0;
}
A();
```
해당 함수가 실행되는 순서를 메모리 구조 관점에서 보면 다음과 같다.

> 1. 자바스크립트의 `A` 함수가 실행될 때, `Frame`의 단위로 콜 스택에 올라간다. Frame은 해당 함수가 호출될 떄의 파라미터, 함수 내부의 지역변수를 포함하여 생성된다. 이를 `FrameA` 라고 하자.
> 2. 함수 내부에 또 다른 함수`B`가 있다면, 콜스택에 쌓여있던 `FrameA` 위에 해당 함수의 프레임인 `FrameB`가 쌓인다.
> 3. `B`가 수행을 완료하면, `FrameB`는 콜 스택의 밖으로 꺼내지게 된다.
> 4. 이후 다시, `A` 함수로 돌아와 로직을 수행하고 최종적으로 `0`을 반환하게 된다.


## 콜백 큐는 콜백 함수가 콜스택에 올라가기 전에 대기하는 장소이다.
만약 콜 스택만으로 런타임 모델이 동작하게 된다면, 한 함수의 수행 시간이 굉장히 오래걸렸을 때, 모든 프로세스가 멈춰야하는 문제가 발생한다.
    
이를 방지하고자, 상대적으로 처리 시간이 오래 걸리는 I/O 작업이나, `setTimeOut` 같은 함수를 콜백 함수로 호출했을 때, 해당 함수가 적절한 시간에 실행될 수 있도록 대기하는 콜백 큐에 들어가게 된다.

```js
function A() {
  setTimeout(() => console.log('콜백 큐에 들어갈 콜백 함수'), 1000);
}
A();
```
콜백 함수가 콜백 큐에 들어갈 때, `Message`라는 콜백 함수를 처리하는 객체의 형태로 큐에 들어가게 된다. **이벤트 루프는 임의 시점에, 가장 오래된 메시지를 큐에서 꺼내 처리하며, 메세지와 연결된 함수를 호출하여 콜 스택 프레임을 생성**한다.
   
각 메세지는 다른 메세지에 영향을 주지 않으며, 반드시 한 메시지가 끝나야 다음 메시지가 실행된다(Run-to-Completion)

# 참고글
- [MDN - Event Loop](https://developer.mozilla.org/ko/docs/Web/JavaScript/Event_loop)
- [Blocking/Non-Blocking, Sync/Async](https://joooing.tistory.com/entry/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9)