{"componentChunkName":"component---src-templates-blog-post-js","path":"/03Concurreny/","result":{"data":{"site":{"siteMetadata":{"title":"Palad Tech Blog"}},"markdownRemark":{"id":"ab80d9bb-f794-5e48-a918-d1e72ea8c2ee","excerpt":"Javascript는 기본적으로 싱글 스레드(Single Threaded…","html":"<p>Javascript는 기본적으로 싱글 스레드(Single Threaded) 구조로써, 한 번의 요청을 수행하는 동안, 다른 요청을 처리할 수 없다. 하지만 우리는 비동기 함수를 사용하면서 마치 동시에 여러 스레드가 수행되는 것처럼 병렬 로직을 작성하기도 했다.(<code class=\"language-text\">Promise.all</code>)</p>\n<p>결론부터 말하자면, 자바스크립트 자체만으로는 병렬 처리를 할 수 없다. <strong>비동기 함수 또한 사실, 직렬로 처리된다. 단지 적절한 시간에 지연되어 실행될 뿐이다.</strong></p>\n<p>비동기 함수가 어떻게 처리 되는지는 자바스크립트 런타임 환경의 이벤트 루프의 작동 원리를 통해 이해할 수 있다.</p>\n<h1>자바스크립트의 실행 구조와 런타임 모델의 작동 원리</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 630px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/d738e2d2d71946b120d03d73a7c9d479/914ae/img.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60.12658227848101%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACRUlEQVR42n1Ty44SQRRl72cZ/2ESXZi4mIVx6SPuTVxoNDExxi8gxpVhOT4C0wzQDAy0gNDNu+lGaF7ppunHVB1vlcAwarzJTaWqq84999zTCdu20el0YJomhsMhZR+W1ad1sN0P0ev1sNlsIIJzjl3EwQauYyP0vf1ZQoAtlwtEUYQgCLG2XsGqHMH7mUQQcsRxJIvN5/PtE4aPHY6nBYbXlRjPCgGel2I8yTOoE46EYLCrLmLWOsaHNzfgmi+uzmYzybJS1WB2DbzUgFupGHe/ctyhvP2F42bqEqn+FtD3fWIXyPSdT+DLdwhWGaz9SAJOp1M4joOQuqA+8b7OcZxmeJxjeHjG8IjWe98YPo8I0LIsqVO1pOHivIRa3YA1XkD73oSqFtDtdjEajUiW5ZYvx9sax9EJwwOF4f4pZYbJ/YlJgLZtodXUoc0LpM4lPNeDks2Q+Ew+XywWqNVqcF33r6H8KyRDQ9cxjAcIVQXu1EGemO1itVqhXq9fA+R7rlfBt5mwCVA3dERtamnQg0cTz+X/D/jnepiSoQDcNC2UyRkzd42zrCJtInQT+jUajb2Ghy0zxvZA11putVrkwxD6CpivPJxm0mgbBjrtNn4QWLPZlIMT0xYWE54VBQ26I97qJNlkMpHfDgB/W8Rbr5FJpzHo92ESSIvAhPlVVUUymYRDnhT3y6UStGoVF+UyGiSJGJ4omhB/QZU+FNUi1OI5ynShRJcVRUE2m0Uul5MMROttYiwKC6biTBQSLIXpx+OxPP8Fgv1yYiI0xqMAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"img.png\"\n        title=\"\"\n        src=\"/static/d738e2d2d71946b120d03d73a7c9d479/f058b/img.png\"\n        srcset=\"/static/d738e2d2d71946b120d03d73a7c9d479/c26ae/img.png 158w,\n/static/d738e2d2d71946b120d03d73a7c9d479/6bdcf/img.png 315w,\n/static/d738e2d2d71946b120d03d73a7c9d479/f058b/img.png 630w,\n/static/d738e2d2d71946b120d03d73a7c9d479/914ae/img.png 860w\"\n        sizes=\"(max-width: 630px) 100vw, 630px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>위의 그림을 보면 다음을 알 수 있다.</p>\n<ul>\n<li>Javascript 엔진 자체만으로는 크게 메모리 힙과 콜 스택의 자료 구조를 가지고 있다.</li>\n<li>Javascript를 실행하는 런타임 모델은 콜백 큐라는 자료구조를 가지고, 이벤트 루프를 통해 제어되고 있다.</li>\n<li>위의 그림에서 Web APIs는 클라이언트 사이드 Web APIs(DOM, AJAX ...)로 브라우저에서 자바스크립트가 호출할 수 있는 대부분의 비동기 함수를 포함한다.</li>\n</ul>\n<blockquote>\n<p>위의 그림을 브라우저 환경이 아닌 Node.js 환경으로 대체한다면, Web APIs 대신 비동기적으로 동작하는 Node.js 내장 모듈로 대체할 수 있다,(fs, dns...)</p>\n</blockquote>\n<p>자바스크립트가 실행될 수 있는, 자바스크립트 엔진부터 살펴보자.</p>\n<h2>함수는 콜스택의 최상단에 올라야 비로소 실행된다.</h2>\n<p>다음과 같은 자바스크립트 로직이 있다고 해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token constant\">B</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token number\">0</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>해당 함수가 실행되는 순서를 메모리 구조 관점에서 보면 다음과 같다.</p>\n<blockquote>\n<ol>\n<li><code class=\"language-text\">A</code> 함수가 실행될 때, <code class=\"language-text\">Frame</code>의 단위로 콜 스택에 올라간다. <code class=\"language-text\">Frame</code>은 해당 함수가 호출될 때의 파라미터, 함수 내부의 지역변수를 포함하여 생성된다. 이를 <code class=\"language-text\">FrameA</code> 라고 하자.</li>\n<li>함수 내부에 또 다른 함수<code class=\"language-text\">B</code>가 있다면, 콜스택에 쌓여있던 <code class=\"language-text\">FrameA</code> 위에 해당 함수의 프레임인 <code class=\"language-text\">FrameB</code>가 쌓인다.</li>\n<li><code class=\"language-text\">B</code>가 수행을 완료하면, <code class=\"language-text\">FrameB</code>는 콜 스택의 밖으로 꺼내지게 된다.</li>\n<li>이후 다시, <code class=\"language-text\">FrameA</code>가 최상단에서 실행되면서, 최종적으로 <code class=\"language-text\">0</code>을 반환하게 된다.</li>\n</ol>\n</blockquote>\n<p>하지만, 이것만으론 비동기 함수를 설명할 수 없다. 만약 <strong>한 함수가 콜 스택의 최상단을 차지하는 시간이 너무 길다면, 싱글 스레드인 자바스크립트로써는 다른 모든 작업을 멈춰야만 한다</strong>.</p>\n<p>이러한 자바스크립트의 한계를 런타임(브라우저, Node.js) 차원에서 도와주는 방법이, <strong>콜백 큐와 이벤트 루프</strong>이다.</p>\n<h2>콜백 큐는 콜백 함수(비동기 함수)가 콜스택에 올라가기 전에 대기하는 장소이다.</h2>\n<p>상대적으로 처리 시간이 오래 걸리는 I/O 작업이나, <code class=\"language-text\">setTimeout</code>와 같은 비동기 함수를 호출했을 때, 해당 함수가 적절한 시간에 실행될 수 있도록 대기하는 콜백 큐에 들어가게 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'콜백 큐에 들어갈 콜백 함수'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>콜백 함수가 콜백 큐에 들어갈 때, <code class=\"language-text\">Message</code>라는 콜백 함수를 처리하는 객체의 형태로 큐에 들어가게 된다. <strong>이벤트 루프는 콜백 큐와 콜 스택을 감시하며, 콜 스택이 비었을 때, 가장 오래된 메시지를 큐에서 꺼내 메세지와 연결된 함수를 호출하여 콜 스택 프레임을 생성</strong>한다.</p>\n<p>각 메세지는 다른 메세지에 영향을 주지 않으며, 반드시 한 메시지가 끝나야 다음 메시지가 실행된다(Run-to-Completion)</p>\n<h1>자바스크립트 직렬 처리의 성능을 끌어올리는 방법</h1>\n<p>위의 사실로, 자바스크립트 자체만으론 비동기 함수, 동기 함수 모두 지연 시간의 차이일 뿐, 결국 하나의 콜스택에서 직렬 방식으로 처리된다는 것을 알 수 있다.</p>\n<p>결국, 자바스크립트 엔진 하나로 모든 것을 감당하기에는 성능 문제가 너무 크다는 것이다.</p>\n<p>하지만, 자바스크립트의 실행은 자바스크립트가 실행되는 런타임 환경을 빼놓고 이야기할 수 없다. 그만큼 런타임 측에서 자바스크립트를 보조하는 것이 많다.</p>\n<h2>C, C++, Rust와 같은 로우 레벨 API를 활용한 성능 향상</h2>\n<blockquote>\n<p>이하 글의 <code class=\"language-text\">외부 시스템</code>은 자바스크립트로 실행되는 환경이 아닌 다른 멀티 쓰레드를 지원하는 언어로 만들어진 환경을 뜻한다. 실제로 브라우저의 Web APIs는 C++, Rust로 이루어진 기능을 자바스크립트로 호출할 수 있게 추상화해둔 것이다. - <a href=\"https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Client-side_web_APIs/Introduction\">MDN Web APIS</a></p>\n</blockquote>\n<p>자바스크립트의 한계, 즉 싱글 스레드만으로는 해결할 수 없는 것들은 예를 들어 다음과 같다.</p>\n<ul>\n<li>클라이언트 사이드(브라우저)의 Web APIs\n<ul>\n<li>DOM Control</li>\n<li>AJAX</li>\n<li>Timer(<code class=\"language-text\">setTimeout</code>... )</li>\n<li>...</li>\n</ul>\n</li>\n<li>서버 사이드(Node.js)의 libuv에서 지원하는 비동기 기능\n<ul>\n<li>파일 시스템 접근 모듈(fs)</li>\n<li>DNS 제어 모듈</li>\n<li>...</li>\n</ul>\n</li>\n</ul>\n<p>자바스크립트는 언어의 한계로 할 수 없는 기능을 C, C++와 같은 로우 레벨로 구현된 API를 호출하므로써 기능을 수행할 수 있게 된다.\n이는 로우 레벨 언어의 성능과 기능을 그대로 사용할 수 있음을 뜻하며 이 덕분에 자바스크립트의 런타임의 성능 또한 크게 상승했다.</p>\n<h2>쉬지않고 콜스택에 함수를 올리는 이벤트 루프와 Promise로 명령 순서 제어하기</h2>\n<p>위에서 <code class=\"language-text\">setTimeout</code>을 사용하는 함수를 다시 한 번 살펴보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'콜백 큐에 들어갈 콜백 함수'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token constant\">A</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>함수가 실행되면 콜스택에 해당 함수가 프레임 단위로 올라가고, 함수가 실행을 끝마칠 때까지, 콜스택의 최상단을 차지하고 있다고 말했다.</p>\n<p>자바스크립트에서 외부 API를 사용할 때도 이러한 원리는 마찬가지이지만, 단 하나가 달라진다.</p>\n<blockquote>\n<ol>\n<li><code class=\"language-text\">A</code> 함수가 실행되면서, <code class=\"language-text\">FrameA</code>가 콜스택 최상단에 올라간다.</li>\n<li><strong>Web APIs의 Timer 기능에 속한 <code class=\"language-text\">setTimeout</code>을 만나면 외부 API의 해당 기능을 호출하며, 콜스택에 해당 함수 프레임을 생성하자마자 바로 콜스택에서 지워버린다.</strong></li>\n<li><code class=\"language-text\">A</code> 함수는 그대로 실행을 종료한다.</li>\n<li>백그라운드에서 <code class=\"language-text\">setTimeout</code> 함수로 인해 1초간 대기 한 후, 콜백 큐에 해당 결과를 <code class=\"language-text\">Message</code>로 추가한다.</li>\n<li><code class=\"language-text\">A</code> 함수가 실행을 종료하여, 콜스택이 빈 상태이므로, 이를 감시하던 이벤트 루프가 외부 API의 결과를 콜백 큐에서 콜 스택으로 올린다.</li>\n<li>콜백 함수(<code class=\"language-text\">console.log</code>)가 실행된다.</li>\n</ol>\n</blockquote>\n<p>여기서 중요한 점은, 결국 콜스택에 비어있을 때, 콜백 함수가 실행되는 것이므로, 만약 콜스택이 비어있지 않다면, 더 많은 시간을 소요하게 된다. 즉 완벽하게 1초를 대기하는 것이 아니라, 시간은 언제든지 달라질 수 있다.</p>\n<p>이러한 현상은 Node.js를 사용할 때 흔하게 볼 수 있다. 이벤트 루프의 원리를 이해하지 못하면, 다음과 같은 코드를 작성했을 때, 원하는 결과가 나오지 않는 것을 볼 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">FindAllUser</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> find_users <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">SELECT * FROM users</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">const</span> users <span class=\"token operator\">=</span> <span class=\"token function\">DBClient</span><span class=\"token punctuation\">(</span>find_users<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 외부 API를 호출했으나, 결과의 반환을 기다리지 않고 다음 줄이 바로 실행됨.</span>\n  \n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>users<span class=\"token punctuation\">)</span> <span class=\"token comment\">// result: undefined</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>즉, 자바스크립트 내부에서 결과값 호출의 순서를 보장하는 기능이 필요해졌다. 한 비동기 함수의 결과값이 오지 않았다면, 다음 함수를 실행하고 싶지 않을 때 <code class=\"language-text\">Promise</code>를 사용하는 것이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">FindAllUser</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> find_users <span class=\"token operator\">=</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">SELECT * FROM users</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">const</span> users <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">DBClient</span><span class=\"token punctuation\">(</span>find_users<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// Promise가 결과값을 이행(Fulfilled) 혹은 거절(Rejected) 될 때까지, 다음 명령줄을 실행하지 않고, 다른 작업을 수행함.</span>\n  \n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>users<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>여기서 다른 작업이란, <strong>마이크로 테스크 큐</strong>와 <strong>매크로 테스크 큐</strong>의 개념을 알고 있어야 이해할 수 있다. 이 주제는 현재 글의 주제에서 벗어나므로 <code class=\"language-text\">Promise</code>가 결과 값을 반환할 때까지 해당 함수를 일시 중지 하고, 마이크로 테스크 큐에 들어가며, 런타임은 마이크로, 매크로 테스크 큐에 있는 다른 작업을 시행한다라고 이해하고 넘어가도록 하자.</p>\n</blockquote>\n<p>이러한 방식으로 외부 API 요청을 통해 자바스크립트로 할 수 없는 기능의 결과만을 이벤트 루프를 통해 제어하고, 비동기 함수가 외부에서 실행되는 동안, 다른 작업을 수행할 수 있게 된다. 이러한 방식을 <strong>Non-Blocking I/O</strong>라고 한다.</p>\n<h1>정리</h1>\n<p>다음의 3가지만 기억하자.</p>\n<ul>\n<li>자바스크립트는 메인 스레드(이벤트 루프) 하나로만 구성되어 있으나, 외부 API는 멀티 스레드 환경에서 실행되므로, 사실상 멀티 스레드 기능을 한다고 볼 수 있다.</li>\n<li>이벤트 루프를 통해 외부 API의 결과를 제어하며, 그 결과는 콜스택이 비어있을 때 실행이 된다. 즉 실행 시간이 반드시 보장되지 않는다.</li>\n<li><code class=\"language-text\">Promise</code>를 통해 API 결과에 대한 순서를 제어할 수 있으며, <code class=\"language-text\">Promise</code> 결과가 반환될 때까지 다른 작업을 수행할 수 있으므로 성능을 크게 끌어올릴 수 있었다.(Non-Blocking I/O)</li>\n</ul>\n<h1>참고글</h1>\n<ul>\n<li><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Event_loop\">MDN - Event Loop</a></li>\n<li><a href=\"https://joooing.tistory.com/entry/%EB%8F%99%EA%B8%B0%EB%B9%84%EB%8F%99%EA%B8%B0-%EB%B8%94%EB%A1%9C%ED%82%B9%EB%85%BC%EB%B8%94%EB%A1%9C%ED%82%B9\">Blocking/Non-Blocking, Sync/Async</a></li>\n<li><a href=\"https://haeunyah.tistory.com/81\">NodeJS 는 Single Thread 일까? Multi Thread 일까?</a></li>\n</ul>","frontmatter":{"title":"자바스크립트는 어떻게 멀티 스레드처럼 동작할 수 있을까?","date":"February 25, 2024","description":"기본적으로 싱글 스레드 구조인 자바스크립트는 한 번에 하나의 요청만을 처리할 수 있다. Node나 브라우저 환경에서는 자바스크립트가 마치 멀티스레드인 것처럼 동작하는 것을 볼 수 있다. 이 원리를 파헤쳐보자."}},"previous":{"fields":{"slug":"/Promise와 Async,Await가 혼용된 함수 리팩토링하기/"},"frontmatter":{"title":"Promise와 async,await가 혼용된 함수 리팩토링하기"}},"next":null},"pageContext":{"id":"ab80d9bb-f794-5e48-a918-d1e72ea8c2ee","previousPostId":"62d4f9a7-e0b1-53d0-ab60-094f9c11e629","nextPostId":null}},"staticQueryHashes":["230163734","2841359383"],"slicesMap":{}}